# 中断和异常
对于 ``x64`` 平台，陷阱/异常的处理非常相似，现在以异常为例。当程序触发了某种错误，比如除以 $0$ 触发的 ``#DE``，这时候就会根据 ``IDT`` 中的对应的描述符（每个中断/异常会有对应的编号），提取出中断/异常处理程序的指针，所在的特权级（方便起见，项目的异常处理程序特权级都在 ring $0$ ），以及栈顶寄存器 ``rsp`` 应当作出的变化（如果 $\texttt{IST}\ne 0$, 那么使用 ``TSS`` 中对应的 $\texttt{IST}$ 项；否则使用 ``TSS`` 中对应特权级的 ``rspX`` ），更多具体内容，请 《GDT, IDT and TSS》。接着CPU会在切换之后的栈中按顺序压入切换之前的 ``ss, rsp, rflags, rip, cs`` ，如果特权级没有变化，那么可能不会压入 ``ss, rsp`` ，但是按照本人经验，确实会压入这 $5$ 个寄存器。接着，如果这个异常存在错误码，那么还会压入一个描述错误原因的，长度为 $64\mathrm{~bits}$ 的错误码 ``errorCode`` . 中断没有错误码。最后，程序会转跳到异常/中断处理程序。

值得注意的是，在执行完成中断/异常处理程序之前，我们会屏蔽所有的中断。

某些异常是不可恢复的，比如 ``#DE`` ，这时候我们需要让整个进程死循环，同时设置该进程为可回收，然后将运行频率降低（将优先度的数值设置为 ``Task_Priority_Trapped`` ），而有些是可以恢复的，比如 ``#GF`` 有可能是因为访问了栈中还没有伸展到的位置，这时候只需要分配物理页，即可重新执行产生错误的指令了。

# 软中断
对于某一些中断，其处理时间会很长，比如进程的调度，这时候，我们接受不到鼠标和键盘的中断，这并不好，因此我们可以在中断/异常处理程序中处理比较应急的部分（比如应答和重新读取键盘），然后保存下需要的用的信息，然后等到软中断期，继续处理中断遗留下的内容。

项目中的 ``interrupt/softirq/`` 文件夹下的所有文件用于实现软中断的架构和某些内置的软中断（比如计时器），``interrupt/entry.S`` 中的 ``Intr_retFromIntr`` 函数中实现了中断程序结束之后转跳到软中断分发函数 ``Intr_SoftIrq_dispatch`` 的功能。